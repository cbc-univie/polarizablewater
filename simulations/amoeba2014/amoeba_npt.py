# This script was generated by OpenMM-Setup on 2024-01-10.

import sys
from openmm import *
from openmm.app import *
from openmm.unit import *

cnt = int(sys.argv[1])
pcnt = cnt-1

if cnt > 1:
    rst = f'traj/npt_{pcnt}.rst'

# Input Files

pdb = PDBFile('hoh_500.pdb')
forcefield = ForceField('amoeba2014.xml')

# System Configuration

nonbondedMethod = PME
nonbondedCutoff = 1.0*nanometers
ewaldErrorTolerance = 0.0005
constraints = None
rigidWater = False
constraintTolerance = 0.000001
hydrogenMass = 1.0*amu

# Integration Options

dt = 0.002*picoseconds
temperature = 300*kelvin
friction = 1.0/picosecond
pressure = 1.0*atmospheres
barostatInterval = 25

# Simulation Options

steps = 1_000_000
equilibrationSteps = 1000
platform = Platform.getPlatformByName('CUDA')
platformProperties = {'Precision': 'mixed'}
dcdReporter = DCDReporter(f'traj/npt_{cnt}.dcd', 1000)
dataReporter = StateDataReporter(f'out/npt_{cnt}.out', 1000, totalSteps=steps,
    step=True, progress=True, potentialEnergy=True, kineticEnergy=True, totalEnergy=True,
    temperature=True, volume=True, density=True, separator='\t')

# Prepare the Simulation

print('Building system...')
topology = pdb.topology
positions = pdb.positions
system = forcefield.createSystem(topology, nonbondedMethod=PME, nonbondedCutoff=1.0*nanometer,
    ewaldErrorTolerance=ewaldErrorTolerance, vdwCutoff=1.1*nanometer,
    constraints=constraints, rigidWater=rigidWater,
    polarization='mutual', mutualInducedTargetEpsilon=0.00001)
system.addForce(MonteCarloBarostat(pressure, temperature, barostatInterval))
for force in system.getForces():
    if isinstance(force, AmoebaMultipoleForce) or isinstance(force, AmoebaVdwForce) or isinstance(force, AmoebaGeneralizedKirkwoodForce):
        force.setForceGroup(1)
integrator = MTSLangevinIntegrator(temperature, friction, dt, [(0,2), (1,1)])
integrator.setConstraintTolerance(constraintTolerance)
simulation = Simulation(topology, system, integrator, platform, platformProperties)
simulation.context.setPositions(positions)

# Minimize and Equilibrate

if cnt > 1:
    with open(rst, 'r') as f:
        simulation.context.setState(XmlSerializer.deserialize(f.read()))

if cnt == 1:
    print('Performing energy minimization...')
    simulation.minimizeEnergy()
    print('Equilibrating...')
    simulation.context.setVelocitiesToTemperature(temperature)
    integrator.setStepSize(0.0001)
    simulation.step(equilibrationSteps)
    simulation.currentStep = 0
    integrator.setStepSize(dt)

# Simulate

print('Simulating...')
simulation.reporters.append(dcdReporter)
simulation.reporters.append(dataReporter)
simulation.step(steps)

state = simulation.context.getState( getPositions=True, getVelocities=True )
with open(f'traj/npt_{cnt}.rst', 'w') as f:
    f.write(XmlSerializer.serialize(state))

crd = simulation.context.getState(getPositions=True).getPositions()
